import React, { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ImagePlus, Download, Wallet, Shuffle, Upload } from 'lucide-react';

const NftMemeMaker = ({
  nftCollectionAddress = '0x1234567890123456789012345678901234567890',
  apiKey = 'YOUR_ALCHEMY_OR_OPENSEA_API_KEY',
}) => {
  // Wallet and NFT states
  const [walletAddress, setWalletAddress] = useState(null);
  const [ownedNfts, setOwnedNfts] = useState([]);
  const [currentNft, setCurrentNft] = useState(null);

  // Meme states
  const [topText, setTopText] = useState('');
  const [bottomText, setBottomText] = useState('');
  const [backgroundImage, setBackgroundImage] = useState(null);
  const [memeColor, setMemeColor] = useState('#000000');
  const [fontSize, setFontSize] = useState(50);
  const [fontFamily, setFontFamily] = useState('Impact');
  const [textAlign, setTextAlign] = useState('center');

  // Loading and Error States
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Refs
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  // Fetch NFTs for a specific collection
  const fetchNftsForCollection = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(
        `https://eth-mainnet.alchemyapi.io/v2/${apiKey}/getNFTs/?owner=${walletAddress}&contractAddresses[]=${nftCollectionAddress}`
      );

      const data = await response.json();

      const nftList = data.ownedNfts.map((nft) => ({
        id: nft.id.tokenId,
        name: nft.title || `NFT #${nft.id.tokenId}`,
        image: nft.media[0]?.gateway || nft.media[0]?.raw,
        description: nft.description || 'No description',
      }));

      setOwnedNfts(nftList);

      if (nftList.length > 0) {
        selectNft(nftList[0]);
      }
    } catch (error) {
      console.error('Error fetching NFTs', error);
      setError('Failed to fetch NFTs. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // Connect Wallet
  const connectWallet = async () => {
    if (window.ethereum) {
      try {
        const accounts = await window.ethereum.request({
          method: 'eth_requestAccounts',
        });

        setWalletAddress(accounts[0]);
        await fetchNftsForCollection();
      } catch (error) {
        console.error('Wallet connection failed', error);
        setError('Failed to connect wallet. Please try again.');
      }
    } else {
      setError('Please install a Web3 wallet like MetaMask!');
    }
  };

  // Fetch Random NFT from Collection
  const fetchRandomNft = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const randomTokenId = Math.floor(Math.random() * 10000);
      const response = await fetch(
        `https://api.opensea.io/api/v1/asset/${nftCollectionAddress}/${randomTokenId}/`,
        {
          headers: {
            'X-API-KEY': apiKey,
          },
        }
      );

      const nftData = await response.json();

      if (nftData.success === false) {
        throw new Error('NFT not found');
      }

      const randomNft = {
        id: nftData.token_id,
        name: nftData.name || `NFT #${nftData.token_id}`,
        image: nftData.image_url,
        description: nftData.description || 'No description',
      };

      selectNft(randomNft);
    } catch (error) {
      console.error('Error fetching random NFT', error);
      setError('Failed to fetch random NFT. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // Select NFT
  const selectNft = (nft) => {
    setBackgroundImage(nft.image);
    setCurrentNft(nft);
  };

  // Generate Meme
  const generateMeme = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;

      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      ctx.font = `bold ${fontSize}px ${fontFamily}`;
      ctx.textAlign = textAlign;
      ctx.fillStyle = memeColor;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = fontSize / 20;

      if (topText) {
        ctx.fillText(topText, canvas.width / 2, fontSize + 10);
        ctx.strokeText(topText, canvas.width / 2, fontSize + 10);
      }

      if (bottomText) {
        ctx.fillText(
          bottomText,
          canvas.width / 2,
          canvas.height - 10
        );
        ctx.strokeText(
          bottomText,
          canvas.width / 2,
          canvas.height - 10
        );
      }
    };
    img.src = backgroundImage;
  };

  // Download Meme
  const downloadMeme = () => {
    generateMeme();
    const canvas = canvasRef.current;
    const link = document.createElement('a');
    link.download = `nft-meme-${currentNft ? currentNft.name : 'random'}.png`;
    link.href = canvas.toDataURL();
    link.click();
  };

  // Upload Image
  const uploadImage = (e) => {
    const file = e.target.files[0];
    if (file) {
      const img = new Image();
      img.onload = () => {
        setBackgroundImage(img.src);
        setCurrentNft(null);
      };
      img.src = URL.createObjectURL(file);
    }
  };

  // Render component
  return (
    <div className="container mx-auto p-4 max-w-md">
      <Card>
        <CardHeader>
          <CardTitle className="text-center">NFT Meme Maker</CardTitle>
          <p className="text-center text-sm text-gray-500">
            Collection: {nftCollectionAddress}
          </p>
        </CardHeader>
        <CardContent>
          {/* Wallet Connection */}
          <div className="mb-4">
            {!walletAddress ? (
              <Button onClick={connectWallet} className="w-full">
                <Wallet className="mr-2" /> Connect Wallet
              </Button>
            ) : (
              <div className="flex items-center justify-between">
                <span>
                  Connected: {walletAddress.substring(0, 6)}...
                  {walletAddress.substring(walletAddress.length - 4)}
                </span>
                <Button
                  variant="outline"
                  onClick={() => setWalletAddress(null)}
                >
                  Disconnect
                </Button>
              </div>
            )}
          </div>

          {/* Error Message */}
          {error && (
            <div className="mb-4 text-red-500 text-center">{error}</div>
          )}

          {/* Loading Indicator */}
          {isLoading && (
            <div className="mb-4 text-center">Loading...</div>
          )}

          {/* NFT Selection */}
          <div className="mb-4 space-y-2">
            {walletAddress && ownedNfts.length > 0 ? (
              <>
                <select
                  onChange={(e) =>
                    selectNft(ownedNfts[e.target.selectedIndex])
                  }
                  className="w-full p-2 border rounded mb-2"
                >
                  {ownedNfts.map((nft, index) => (
                    <option key={index} value={nft.id}>
                      {nft.name}
                    </option>
                  ))}
                </select>

                {/* NFT Image Preview */}
                {backgroundImage && (
                  <div className="w-full flex justify-center mb-2">
                    <img
                      src={backgroundImage}
                      alt="Selected NFT"
                      className="max-w-full h-auto max-h-64 object-contain border rounded"
                    />
                  </div>
                )}
              </>
            ) : (
              <div className="space-y-2">
                <Button
                  onClick={fetchRandomNft}
                  className="w-full"
                  variant="secondary"
                >
                  <Shuffle className="mr-2" /> Fetch Random NFT
                </Button>
                <div className="flex items-center justify-center">
                  <span className="mx-2">or</span>
                </div>
                <Button
                  onClick={() => fileInputRef.current.click()}
                  className="w-full"
                >
                  <Upload className="mr-2" /> Upload Image
                </Button>
                <input
                  type="file"
                  accept="image/*"
                  ref={fileInputRef}
                  onChange={uploadImage}
                  className="hidden"
                />
              </div>
            )}
          </div>

          {/* No NFT Selected Placeholder */}
          {!backgroundImage && (
            <div className="w-full h-64 border-2 border-dashed flex items-center justify-center text-gray-400 mb-4">
              No Image Selected
            </div>
          )}

          {/* Meme Text Inputs */}
          <div className="space-y-2 mb-4">
            <Input
              placeholder="Top Text"
              value={topText}
              onChange={(e) => setTopText(e.target.value)}
            />
            <Input
              placeholder="Bottom Text"
              value={bottomText}
              onChange={(e) => setBottomText(e.target.value)}
            />
          </div>

          {/* Font Customization */}
          <div className="space-y-2 mb-4">
            <div className="flex items-center space-x-2">
              <label className="w-1/3">Font Size</label>
              <Input
                type="number"
                value={fontSize}
                onChange={(e) => setFontSize(e.target.value)}
                className="w-2/3"
                min="10"
              />
            </div>
            <div className="flex items-center space-x-2">
              <label className="w-1/3">Font Family</label>
              <select
                value={fontFamily}
                onChange={(e) => setFontFamily(e.target.value)}
                className="w-2/3 p-2 border rounded"
              >
                <option value="Impact">Impact</option>
                <option value="Arial">Arial</option>
                <option value="Comic Sans MS">Comic Sans MS</option>
                <option value="Times New Roman">Times New Roman</option>
              </select>
            </div>
            <div className="flex items-center space-x-2">
              <label className="w-1/3">Text Align</label>
              <select
                value={textAlign}
                onChange={(e) => setTextAlign(e.target.value)}
                className="w-2/3 p-2 border rounded"
              >
                <option value="center">Center</option>
                <option value="left">Left</option>
                <option value="right">Right</option>
              </select>
            </div>
          </div>

          {/* Color Picker */}
          <div className="flex items-center space-x-2 mb-4">
            <label className="w-1/3">Text Color</label>
            <Input
              type="color"
              value={memeColor}
              onChange={(e) => setMemeColor(e.target.value)}
              className="w-2/3"
            />
          </div>

          {/* Meme Actions */}
          <div className="space-y-2">
            <Button
              onClick={generateMeme}
              className="w-full"
              disabled={!backgroundImage}
            >
              Generate Meme
            </Button>
            <Button
              onClick={downloadMeme}
              className="w-full"
              disabled={!backgroundImage}
            >
              <Download className="mr-2" /> Download Meme
            </Button>
          </div>

          {/* Hidden Canvas */}
          <canvas ref={canvasRef} className="hidden" />
        </CardContent>
      </Card>
    </div>
  );
};

export default NftMemeMaker;
